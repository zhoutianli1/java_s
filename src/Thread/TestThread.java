package Thread;

/**
 * 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
 * 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。
 * 这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。
 * 一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。
 * 新建状态:
 * 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
 * 就绪状态:
 * 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
 * 运行状态:
 * 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
 * 阻塞状态:
 * 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
 * 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
 * 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)
 * 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
 * 死亡状态:
 * 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。
 */
public class TestThread {
    public static void main(String args[]) {
        /**
         * 有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程\
         *
         * Java 提供了三种创建线程的方法：
         * 通过实现 Runnable 接口；
         * 通过继承 Thread 类本身；
         * 通过 Callable 和 Future 创建线程。
         *
         * 在java线程中 start与run的不同
         * start与run方法的主要区别在于当程序调用start方法一个新线程将会被创建，并且在run方法中的代码将会在新线程上运行，
         * 然而在你直接调用run方法的时候，程序并不会创建新线程，run方法内部的代码将在当前线程上运行。
         * 大多数情况下调用run方法是一个bug或者变成失误。因为调用者的初衷是调用start方法去开启一个新的线程，
         * . 如果你想要运行需要消耗大量时间的任务，你最好使用start方法，否则在你调用run方法的时候，你的主线程将会被卡住
         *
         * 调用start后自然而然运行 run()方法
         *线程开启不一定立刻执行，  由cpu调度执行
         */
        //在主线程中 新建2 个子线程。主线程和2个子线程 交替进行
        //实现runnable方法
        RunnableDemo R1 = new RunnableDemo( "Runnable-Thread-1");
        R1.start();

        RunnableDemo R2 = new RunnableDemo( "Runnable-Thread-2");
        R2.start();

        //继承Thread来创建线程
        ThreadDemo T1 = new ThreadDemo( "Thread-1");
        T1.start();

        ThreadDemo T2 = new ThreadDemo( "Thread-2");
        T2.start();
    }
}
